# Dzmitry Pilipenka
# Homework-4
# 31.03.2025 # Дата указана верно, спасибо!
# Grodno-IT-Academy-Python 3.10

# Привет, Дмитрий! Хорошая работа над заданием.
# Код в целом понятен, но есть несколько важных моментов, которые нужно исправить,
# чтобы он соответствовал требованиям тестов и лучшим практикам.
# Также рекомендую добавлять строки документации (docstrings) ко всем функциям.

# теперь тесты написаны с использованием библиотеки pytest
# нам нужно ее установить: pip install pytest
# и запустить как обычный файл: pytest test_Homework4.py
# Теперь вы будете знакомы со вторым инструментом для тестирования
# Отлично, что оставил эти комментарии!

#Выведите n-ое число Фибоначчи, используя только временные переменные, циклические операторы и условные операторы. n - вводится.

def fibonacci(n):
    # Молодец, что добавил проверку на отрицательные числа! Это делает функцию надежнее.
    if n < 0:
        raise ValueError("n должно быть неотрицательным")
    # Базовые случаи для n=0 и n=1 реализуют стандартную последовательность Фибоначчи (0, 1, 1, 2...).
    elif n == 0:
        return 0
    elif n == 1:
        # Ошибка: Тесты (`test_fib_values`) ожидают последовательность, где F_test(1)=0, F_test(2)=1.
        # Твоя функция возвращает 1 для n=1, что не соответствует тесту.
        # Тест ожидает для n=1 результат 0.
        # Для n=2 тест ожидает 1, твоя функция вернет 1 (0+1).
        # Для n=3 тест ожидает 1, твоя функция вернет 2 (1+1). И так далее.
        return 1

    # Инициализация и цикл верны для стандартной последовательности Фибоначчи.
    a, b = 0, 1
    # Цикл выполняется корректное число раз для вычисления F(n) стандартной последовательности.
    for _ in range(2, n + 1):
        a, b = b, a + b
    # Возвращает n-й член стандартной последовательности Фибоначчи.
    return b
    # Рекомендация: Чтобы пройти тесты, тебе нужно адаптировать функцию.
    # Она должна возвращать (n-1)-й член стандартной последовательности для n>=1.
    # Можно изменить базовые случаи:
    # if n == 1: return 0
    # if n == 2: return 1
    # И скорректировать цикл или возвращаемое значение соответственно.


#Определите, является ли число палиндромом (читается слева направо и справа налево одинаково). Число положительное целое, произвольной длины. Задача требует работать только с числами (без конвертации числа в строку или что-нибудь еще).

# Ошибка: Ты определил функцию `palindrome` дважды. Python будет использовать только второе определение.
# Первое определение (`return False`) нужно удалить.
def palindrome(n):
    return False # <-- Эту функцию нужно полностью удалить

def palindrome(n): # Используется это определение
    # Добавь, пожалуйста, проверку на отрицательные числа (они не палиндромы)
    # и на однозначные числа (они всегда палиндромы).
    # if n < 0:
    #     return False
    # if n < 10:
    #     return True
    # Без проверки `n < 10` твоя функция неверно обработает однозначные числа (кроме 0).
    # Например, для n=5, original=5, reversed_num=0, вернется False.

    original = n
    reversed_num = 0

    # Логика разворота числа с помощью арифметики реализована правильно! Молодец.
    while n > 0:
        digit = n % 10  # Получаем последнюю цифру
        reversed_num = reversed_num * 10 + digit  # Добавляем цифру к перевернутому числу
        n //= 10  # Удаляем последнюю цифру

    return original == reversed_num


#Напишите генератор, который возвращает цифры от S до N, но вместо чисел, кратных 3 пишет Fizz, вместо чисел кратный 5 пишет Buzz, а вместо чисел одновременно кратных и 3 и 5 - FizzBuzz.

def fizz_buzz(S, N):
    # Ошибка: Цикл `range(S, N + 1)` работает правильно только если S <= N.
    # Если S > N (как в тесте `test_fizz_buzz_15_1`), range вернет пустую последовательность,
    # и генератор ничего не выдаст.
    # Нужно определить шаг (1 или -1) и использовать его в range.
    # Пример:
    # step = 1 if S <= N else -1
    # for num in range(S, N + step, step):

    for num in range(S, N + 1): # <-- Этот range нужно исправить для случая S > N
        # Порядок проверок верный: сначала на делимость на 15 (или 3 и 5), потом на 3, потом на 5.
        if num % 3 == 0 and num % 5 == 0:
            yield "FizzBuzz"
        elif num % 3 == 0:
            yield "Fizz"
        elif num % 5 == 0:
            yield "Buzz"
        else:
            # Ошибка: Тесты ожидают получить строку 'число', а не само число.
            # Нужно преобразовать `num` в строку.
            yield str(num) # Исправлено: yield num -> yield str(num)
            # yield num # <-- Неправильно

# Пример использования
# Этот код для ввода/вывода полезен для ручной проверки, но его нужно убрать
# из файла, который ты сдаешь на проверку, так как он не является частью
# решения задачи и может помешать автоматическому тестированию.
# S = int(input("Введите начальное число S: "))
# N = int(input("Введите конечное число N: "))
#
# for result in fizz_buzz(S, N):
#     print(result)

# Пожалуйста, исправь указанные ошибки в функциях fibonacci, palindrome и fizz_buzz,
# удали дублирующую функцию и примеры использования.
# Добавление docstrings также улучшит качество кода. Удачи!
